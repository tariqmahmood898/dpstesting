"use strict";(self.webpackChunkmytonwallet=self.webpackChunkmytonwallet||[]).push([[642],{17642:(e,t,i)=>{i.r(t),i.d(t,{BleConnector:()=>te});var n=i(12757),r=i(54011),c=i(31481),o=i(71108),a=i(17276),s=i(15123),d=i(24450),u=i(13983),h=i(13648),l=i(72985),w=i(44240),v=i(9162),f=i(72316),p=i(37968),g=i(62467),y=i(13288),m=i(59099),T=i(66847),b=i(69850),E=i(81160),D=i(65277),C=i(8767),x=i(1005),I=i(93776),k=i(48287).Buffer;const S=e=>e&&e.message&&(e.message.includes("was disconnected")||e.message.includes("not found"))?new d.DisconnectedDevice:e,F=e=>{throw e??new Error};var P=i(48287).Buffer;const L="ble-verbose",M={pairingThreshold:1e3,delayAfterFirstPairing:4e3},U={},B={},O={requestMTU:156,connectionPriority:1},A=(e,t)=>{const i=B[e];i&&i.disconnectTimeout&&((0,h.trace)({type:L,message:"Clearing queued disconnect",context:t}),clearTimeout(i.disconnectTimeout))};let N;class $ extends u.Ay{static disconnectTimeoutMs=5e3;static list=()=>{throw new Error("not implemented")};static listen(e){let t=!1;return new h.LocalTracer(L).trace("Listening for devices ..."),n.Fk.getConnectedDevices((0,o.gq)()).then((async i=>{if(!t){for(const t of i)e.next({type:"add",device:t});await n.Fk.stopLEScan(),n.Fk.requestLEScan({services:(0,o.gq)()},(i=>{t||e.next({type:"add",device:i.device})}))}})),{unsubscribe:async()=>{t=!0,await n.Fk.stopLEScan()}}}static async open(e,t,i){let{rxjsScheduler:n}=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return R(e,!0,t,i,{rxjsScheduler:n})}static disconnectDevice=async(e,t,i)=>{const r=new h.LocalTracer(L,i);r.trace(`Trying to disconnect device ${e}`);try{await n.Fk.disconnect(e),null==t||t()}catch(e){r.withType("ble-error").trace("Error while trying to cancel device connection",{error:e})}r.trace(`Device ${e} disconnected`)};disconnectTimeout=null;isConnected=!0;mtuSize=20;notYetDisconnected=!0;constructor(e,t,i,n,r){let{context:c,rxjsScheduler:o}=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{};super({context:c,logType:L}),this.id=e.deviceId,this.device=e,this.writableWithResponseCharacteristic=t,this.writableWithoutResponseCharacteristic=i,this.notifyObservable=n,this.deviceModel=r,this.rxjsScheduler=o,this.currentTransactionIds=[],A(this.id),this.tracer.trace(`New instance of BleTransport for device ${this.id}`)}exchange=(()=>{var e=this;return function(t){let{abortTimeoutMs:i}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};e.exchangeBusyPromise&&$.disconnectDevice(e.id,e.onDisconnect);const n=e.tracer.withUpdatedContext({function:"exchange"});return n.trace("Exchanging APDU ...",{abortTimeoutMs:i}),n.withType("apdu").trace(`=> ${t.toString("hex")}`),e.exchangeAtomicImpl((()=>(0,l._)((0,w.h)(e.notifyObservable.pipe((e=>(0,a.m)(e,{context:n.getContext()}))),(0,s.sendAPDU)(e.write,t,e.mtuSize,{context:n.getContext()})).pipe(i?(0,v.w)(i,e.rxjsScheduler):(0,m.M)(),(0,m.M)((e=>{n.withType("apdu").trace(`<= ${e.toString("hex")}`)})),(0,T.W)((async t=>{if(t instanceof v.M)throw n.trace("Aborting due to timeout and trying to cancel all communication write of the current exchange",{abortTimeoutMs:i,transactionIds:e.currentTransactionIds}),await e.cancelPendingOperations(),new d.TransportExchangeTimeoutError("Exchange aborted due to timeout");n.withType("ble-error").trace("Error while exchanging APDU",{error:t}),e.notYetDisconnected&&await $.disconnectDevice(e.id,e.onDisconnect);const r=S(t);throw n.trace("Error while exchanging APDU, mapped and throws following error",{mappedError:r}),r})),(0,b.j)((()=>{n.trace("Clearing current transaction ids",{currentTransactionIds:e.currentTransactionIds}),e.clearCurrentTransactionIds()}))))))}})();async cancelPendingOperations(){await $.disconnectDevice(this.id,this.onDisconnect)}clearCurrentTransactionIds(){this.currentTransactionIds=[]}async inferMTU(){let e=await n.Fk.getMtu(this.device.deviceId);return this.tracer.trace("Inferring MTU ...",{currentDeviceMtu:e}),await this.exchangeAtomicImpl((async()=>{try{e=await(0,l._)((0,w.h)(this.notifyObservable.pipe((0,E.T)((e=>{if(e instanceof Error)throw e;return e})),(0,D.$)((e=>8===e.readUInt8(0))),(0,E.T)((e=>e.readUInt8(5)))),(0,f.v)((()=>(0,p.H)(this.write(P.from([8,0,0,0,0]))))).pipe((0,C.w)())))}catch(t){this.tracer.withType("ble-error").trace("Error while inferring MTU",{mtu:e}),await $.disconnectDevice(this.id,this.onDisconnect);const i=S(t);throw this.tracer.trace("Error while inferring APDU, mapped and throws following error",{mappedError:i}),i}finally{this.clearCurrentTransactionIds()}})),this.tracer.trace("Successfully negotiated MTU with device",{mtu:e,mtuSize:this.mtuSize}),e>20&&(this.mtuSize=e),this.mtuSize}async requestConnectionPriority(e){let t;switch(e){case"High":case"Balanced":t=n.rj.CONNECTION_PRIORITY_BALANCED;break;case"LowPower":t=n.rj.CONNECTION_PRIORITY_LOW_POWER}var i;await(i=n.Fk.requestConnectionPriority(this.device.deviceId,t),i.catch(F))}write=async e=>{const t=(0,r.A)();this.currentTransactionIds.push(t);const i=this.tracer.withUpdatedContext({transactionId:t});i.trace("Writing to device",{willMessageBeAcked:!this.writableWithoutResponseCharacteristic});try{const t=new Uint8Array(e),r=new DataView(t.buffer,t.byteOffset,t.byteLength);await n.Fk.write(this.device.deviceId,N,this.writableWithResponseCharacteristic.uuid,r),i.withType("ble-frame").trace(`=> ${e.toString("hex")}`)}catch(e){throw i.trace("Error while writing APDU",{error:e}),new d.DisconnectedDeviceDuringOperation(e instanceof Error?e.message:`${String(e)}`)}};async close(){const e=this.tracer.withUpdatedContext({function:"close"});let t;e.trace("Closing, queuing a disconnect with a timeout ...");const i=new Promise((e=>{t=e}));A(this.id),this.disconnectTimeout=setTimeout((()=>{e.trace("Disconnect timeout has been reached ..."),this.isConnected?$.disconnectDevice(this.id,this.onDisconnect,e.getContext()).catch((()=>{})).finally(t):t()}),$.disconnectTimeoutMs),await Promise.race([this.exchangeBusyPromise||Promise.resolve(),i])}}async function R(e,t,i,r){let{rxjsScheduler:c}=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};const a=new h.LocalTracer(L,r);let s,u,l;if(a.trace(`Opening ${"string"==typeof e?e:e.deviceId}`,{needsReconnect:t}),"string"==typeof e){if(u=e,B[e])return a.trace("Transport in cache, using it"),A(e),B[e].setTraceContext(r),B[e];a.trace(`Trying to open device: ${e}`),await async function(){if(await n.gq.initialize(),!await n.gq.isEnabled())throw new d.BluetoothRequired("",{state:"disable"})}();const t=await n.Fk.getDevices([e]);if(a.trace(`Found ${t.length} already known device(s) with given id`,{deviceOrId:e}),[s]=t,!s){const t=(await n.Fk.getServices(e)).map((e=>e.uuid)),i=(await n.Fk.getConnectedDevices(t)).filter((t=>t.deviceId===e));a.trace(`No known device with given id.\n        Found ${i.length} devices from already connected devices`,{deviceOrId:e}),[s]=i}if(!s){a.trace("No known nor connected devices with given id. Trying to connect to device",{deviceOrId:e,timeoutMs:i});try{await n.Fk.connect(e,(()=>{var e,t;null===(e=(t=l).onDisconnect)||void 0===e||e.call(t)}),{timeout:i})}catch(e){throw a.trace(`Error code: ${e.errorCode}`),e}}if(!s)throw new d.CantOpenDevice}else s=e,u=e.deviceId;if(!(await n.Fk.getConnectedDevices((0,o.gq)())).find((e=>e.deviceId===u))){a.trace("Device found but not connected. connecting...",{timeoutMs:i,connectOptions:O});try{await n.Fk.connect(u,(()=>{var e,t;null===(e=(t=l).onDisconnect)||void 0===e||e.call(t)}),{timeout:i})}catch(e){throw a.trace("Connect error",{error:e}),S(e)}}a.trace("Device is connected now, getting services and characteristics");let w=[];await n.Fk.discoverServices(u),w=await n.Fk.getServices(u);let v=function(e){if(!e||!e.uuids)return;const[t]=e.uuids;if(!t)return;const i=(0,o.R6)(t);return i?(U[e.deviceId]=i,i):void 0}(s);const f=[];if(!v)for(const e of(0,o.gq)())try{const t=w.find((t=>t.uuid===e));if(v=(0,o.R6)(e),v&&t){f.push(...t.characteristics),N=v.serviceUuid;break}}catch(e){}if(!v)throw a.trace("Service not found"),new d.TransportError("service not found","BLEServiceNotFound");const{deviceModel:p,writeUuid:b,writeCmdUuid:E,notifyUuid:D}=v;if(!f)throw a.trace("Characteristics not found"),new d.TransportError("service not found","BLEServiceNotFound");let C,F,P;for(const e of f)e.uuid===b?C=e:e.uuid===E?F=e:e.uuid===D&&(P=e);if(!C)throw new d.TransportError("write characteristic not found","BLECharacteristicNotFound");if(!P)throw new d.TransportError("notify characteristic not found","BLECharacteristicNotFound");if(!C.properties.write)throw new d.TransportError("The writable-with-response characteristic is not writable with response","BLECharacteristicInvalid");if(!P.properties.notify)throw new d.TransportError("notify characteristic not notifiable","BLECharacteristicInvalid");if(F&&!F.properties.writeWithoutResponse)throw new d.TransportError("The writable-without-response characteristic is not writable without response","BLECharacteristicInvalid");const q=await n.Fk.getMtu(s.deviceId);a.trace(`device.mtu=${q}`);const z=((e,t,i,r)=>new I.c((c=>(new h.LocalTracer("ble-verbose",r).trace("Start monitoring BLE characteristics",{characteristicUuid:i.uuid}),n.Fk.startNotifications(e,t,i.uuid,(e=>{const t=new Uint8Array(e.buffer),i=k.from(t);c.next(i)})),()=>{n.Fk.stopEnabledNotifications()}))))(u,N,P,r).pipe((0,T.W)((e=>{const t=String(e);return t.includes("notify change failed")?(0,g.of)(new d.PairingFailed(t)):(0,y.$)((()=>e))})),(0,m.M)((e=>{e instanceof d.PairingFailed||(0,h.trace)({type:"ble-frame",message:`<= ${e.toString("hex")}`,context:r})})),(0,x.u)()),j=z.subscribe();l=new $(s,C,F,z,p,{context:r,rxjsScheduler:c}),a.trace("New BleTransport created"),l.onDisconnect=e=>{var t,i;l.isConnected=!1,l.notYetDisconnected=!1,j.unsubscribe(),A(l.id),delete B[l.id],a.trace(`On device disconnected callback: cleared cached transport for ${l.id},\n      emitting Transport event "disconnect. Error: ${e}"`,{reason:e}),l.emit("disconnect",e),null===(t=(i=l).disconnectCallback)||void 0===t||t.call(i)},B[l.id]=l;const W=Date.now();try{await l.inferMTU()}finally{const e=Date.now();M?(e-W<M.pairingThreshold?t=!1:p.id===o.Dp.stax&&(a.trace('Skipping "needsReconnect" strategy for Stax'),t=!1),t&&(a.trace("Device needs reconnection. Triggering a disconnect"),await $.disconnectDevice(l.id,l.onDisconnect),await(_=M.delayAfterFirstPairing,new Promise((e=>setTimeout(e,_)))))):t=!1}var _;return t?(a.trace("Reconnecting"),R(s,!1,i,r)):l}var q=i(55029),z=i(37836),j=i(82393),W=i(32693);let _,Y,H,J,Q=!1,V=[];function Z(){return!!Y}function G(e){return!!V.find((t=>t.identifier===e.identifier))&&!H}async function K(e){try{if(!G(e))return;const t=await $.open(e.device);if(!G(e))return;const i={device:e.device,bleTransport:t};H=i,t.disconnectCallback=()=>{H=void 0,Z()&&(ee(),X())},setTimeout((()=>{var e,t;(null===(e=H)||void 0===e?void 0:e.device.deviceId)===i.device.deviceId?(null===(t=J)||void 0===t||t(i),ee()):Z()&&(H=void 0,ee(),X())}),1e3)}catch(t){setTimeout((()=>{K(e)}),1e4)}}async function X(){await ie(),Y=$.listen({next:e=>{if("add"===e.type&&e.device){if(!e.device.name)return;if(V.find((t=>{var i;return t.device.deviceId===(null===(i=e.device)||void 0===i?void 0:i.deviceId)})))return;const t={identifier:(0,r.A)(),device:e.device};V.push(t),K(t)}},error:()=>{ee()},complete:()=>{ee()}})}function ee(){var e;V=[],null===(e=Y)||void 0===e||e.unsubscribe(),Y=void 0}const te={isSupported:async function(){if(!c.UMQ)return!1;let e=!1;try{await ie(),j.Ni&&await n.Fk.requestEnable(),e=await n.Fk.isEnabled(),(0,q.MD)("BLE isSupported result",{isEnabled:e})}catch(e){(0,q.SJ)("Error while checking BLE availability",e)}return e},connect:function(){return new Promise((e=>{J=e,H?J(H):Z()||X()}))},stop:ee,openSettings:async function(){j.Ni?await n.Fk.openBluetoothSettings():j.pz&&await n.Fk.openAppSettings()}};async function ie(){if(!Q)return _||(_=(async()=>{let e,t=0;for(;t<W.eZ&&!Q;){try{return await n.Fk.initialize({androidNeverForLocation:!0}),void(Q=!0)}catch(i){e=i,(0,q.SJ)("BLE initialize attempt failed",i),await(0,z.v7)(W.Hz*t)}t+=1}if(!Q)throw e??new Error("BLE initialize failed")})().finally((()=>{_=void 0})),_)}}}]);
//# sourceMappingURL=642.9ac8bf3c16187bc49a7f.js.map