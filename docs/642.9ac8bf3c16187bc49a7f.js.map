{"version":3,"file":"642.9ac8bf3c16187bc49a7f.js","mappings":"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","sources":["webpack://mytonwallet/./src/lib/ledger-hw-transport-ble/monitorCharacteristic.ts","webpack://mytonwallet/./src/lib/ledger-hw-transport-ble/remapErrors.ts","webpack://mytonwallet/./src/lib/ledger-hw-transport-ble/BleTransport.ts","webpack://mytonwallet/./src/lib/ledger-hw-transport-ble/awaitsBleOn.ts","webpack://mytonwallet/./src/util/ledger/bleConnector.ts"],"sourcesContent":["import { BleClient } from '@capacitor-community/bluetooth-le';\nimport type { TraceContext } from '@ledgerhq/logs';\nimport { LocalTracer } from '@ledgerhq/logs';\nimport { Observable } from 'rxjs';\n\nimport type { Characteristic } from './types';\n\nconst LOG_TYPE = 'ble-verbose';\n\nexport const monitorCharacteristic = (\n  deviceId: string,\n  serviceId: string,\n  characteristic: Characteristic,\n  context?: TraceContext,\n): Observable<Buffer> => new Observable((o) => {\n  const tracer = new LocalTracer(LOG_TYPE, context);\n  tracer.trace('Start monitoring BLE characteristics', {\n    characteristicUuid: characteristic.uuid,\n  });\n\n  void BleClient.startNotifications(\n    deviceId,\n    serviceId,\n    characteristic.uuid,\n    (value) => {\n      const uint8Array = new Uint8Array(value.buffer);\n      const buffer = Buffer.from(uint8Array);\n      o.next(buffer);\n    },\n  );\n\n  return () => {\n    void BleClient.stopEnabledNotifications();\n  };\n});\n","import {\n  DisconnectedDevice,\n} from '@ledgerhq/errors';\n\nexport type IOBleErrorRemap = Error | null | undefined;\n\nexport const remapError = (error: IOBleErrorRemap): IOBleErrorRemap => {\n  if (!error || !error.message) return error;\n\n  if (error.message.includes('was disconnected') || error.message.includes('not found')) {\n    return new DisconnectedDevice();\n  }\n\n  return error;\n};\n\nexport const rethrowError = (e: Error | null | undefined): never => {\n  // throw remapError(e);\n  throw e ?? new Error();\n};\n\nexport const decoratePromiseErrors = <A>(promise: Promise<A>): Promise<A> => promise.catch(rethrowError);\n","/* eslint-disable @typescript-eslint/no-redundant-type-constituents */\nimport type { BleService } from '@capacitor-community/bluetooth-le';\nimport { BleClient, ConnectionPriority } from '@capacitor-community/bluetooth-le';\nimport type { BluetoothInfos, DeviceModel } from '@ledgerhq/devices';\nimport { DeviceModelId, getBluetoothServiceUuids, getInfosForServiceUuid } from '@ledgerhq/devices';\nimport { receiveAPDU } from '@ledgerhq/devices/lib/ble/receiveAPDU';\n// ---------------------------------------------------------------------------------------------\n// Since this is a react-native library and metro bundler does not support\n// package exports yet (see: https://github.com/facebook/metro/issues/670)\n// we need to import the file directly from the lib folder.\n// Otherwise it would force the consumer of the lib to manually \"tell\" metro to resolve to /lib.\n//\n// TLDR: /!\\ Do not remove the /lib part in the import statements below (@ledgerhq/devices/lib) ! /!\\\n// See: https://github.com/LedgerHQ/ledger-live/pull/879\nimport { sendAPDU } from '@ledgerhq/devices/lib/ble/sendAPDU';\nimport type { HwTransportError } from '@ledgerhq/errors';\nimport {\n  CantOpenDevice,\n  DisconnectedDeviceDuringOperation,\n  PairingFailed,\n  TransportError,\n  TransportExchangeTimeoutError,\n} from '@ledgerhq/errors';\nimport type { Observer as TransportObserver, Subscription as TransportSubscription } from '@ledgerhq/hw-transport';\nimport Transport from '@ledgerhq/hw-transport';\nimport type { TraceContext } from '@ledgerhq/logs';\nimport { LocalTracer, trace } from '@ledgerhq/logs';\nimport type { Observable, SchedulerLike } from 'rxjs';\nimport {\n  defer, firstValueFrom, from, merge, of, throwError, TimeoutError,\n} from 'rxjs';\nimport {\n  catchError, finalize, first, ignoreElements, map, share, tap, timeout,\n} from 'rxjs/operators';\nimport { v4 as uuid } from 'uuid';\nimport type { BleCharacteristic } from '@capacitor-community/bluetooth-le/dist/esm/definitions';\n\nimport type { IOBleErrorRemap } from './remapErrors';\nimport type { Characteristic, Device, ReconnectionConfig } from './types';\n\nimport { awaitsBleOn } from './awaitsBleOn';\nimport { monitorCharacteristic } from './monitorCharacteristic';\nimport { decoratePromiseErrors, remapError } from './remapErrors';\n\nconst LOG_TYPE = 'ble-verbose';\n\n/**\n * This is potentially not needed anymore, to be checked if the bug is still happening.\n */\nconst reconnectionConfig: ReconnectionConfig | null | undefined = {\n  pairingThreshold: 1000,\n  delayAfterFirstPairing: 4000,\n};\n\n// Allows us to give more granulary error messages\nconst bluetoothInfoCache: Record<string, BluetoothInfos> = {};\n\nfunction retrieveInfos(device: Device | null): BluetoothInfos | undefined {\n  if (!device || !device.uuids) return undefined;\n  const [serviceUUID] = device.uuids;\n  if (!serviceUUID) return undefined;\n  const infos = getInfosForServiceUuid(serviceUUID);\n  if (!infos) return undefined;\n\n  // If we retrieved information, update the cache\n  bluetoothInfoCache[device.deviceId] = infos;\n  return infos;\n}\n\nconst delay = (ms: number | undefined) => new Promise((success) => setTimeout(success, ms));\n\n/**\n * A cache of Bluetooth transport instances associated with device IDs.\n * Allows efficient storage and retrieval of previously initialized transports.\n * @type {Object.<string, BluetoothTransport>}\n */\nconst transportsCache: Record<string, BleTransport> = {};\n\n// `connectOptions` is actually used by `react-native-ble-plx` even if comment above `ConnectionOptions` says it's not used\nconst connectOptions: Record<string, unknown> = {\n  // 156 bytes to max the iOS < 10 limit (158 bytes)\n  // (185 bytes for iOS >= 10)(up to 512 bytes for Android, but could be blocked at 23 bytes)\n  requestMTU: 156,\n  // Priority 1 = high.\n  connectionPriority: 1,\n};\n\nconst clearDisconnectTimeout = (deviceId: string, context?: TraceContext): void => {\n  const cachedTransport = transportsCache[deviceId];\n  if (cachedTransport && cachedTransport.disconnectTimeout) {\n    trace({ type: LOG_TYPE, message: 'Clearing queued disconnect', context });\n    clearTimeout(cachedTransport.disconnectTimeout);\n  }\n};\n\nlet currentDeviceService: string | undefined;\n\n/**\n * React Native bluetooth BLE implementation\n * @example\n * import BleTransport from \"@ledgerhq/react-native-hw-transport-ble\";\n */\nexport default class BleTransport extends Transport {\n  static disconnectTimeoutMs = 5000;\n\n  static list = (): Promise<void[]> => {\n    throw new Error('not implemented');\n  };\n\n  /**\n   * Scan for bluetooth Ledger devices\n   * @param observer Device is partial in order to avoid the live-common/this dep\n   * @returns TransportSubscription\n   */\n  static listen(\n    observer: TransportObserver<any, HwTransportError>,\n  ): TransportSubscription {\n    let unsubscribed: boolean = false;\n    const tracer = new LocalTracer(LOG_TYPE);\n    tracer.trace('Listening for devices ...');\n\n    void BleClient.getConnectedDevices(getBluetoothServiceUuids()).then(async (devices) => {\n      if (unsubscribed) return;\n      for (const it of devices) {\n        observer.next({\n          type: 'add',\n          device: it,\n        });\n      }\n      await BleClient.stopLEScan();\n      void BleClient.requestLEScan({\n        services: getBluetoothServiceUuids(),\n      }, (result) => {\n        if (unsubscribed) return;\n        observer.next({\n          type: 'add',\n          device: result.device,\n        });\n      });\n    });\n\n    return {\n      unsubscribe: async () => {\n        unsubscribed = true;\n        await BleClient.stopLEScan();\n      },\n    };\n  }\n\n  /**\n   * Opens a BLE transport\n   *\n   * @param {Device | string} deviceOrId\n   * @param timeoutMs Applied when trying to connect to a device\n   * @param context An optional context object for log/tracing strategy\n   * @param injectedDependencies Contains optional injected dependencies used by the transport implementation\n   *  - rxjsScheduler: dependency injected RxJS scheduler to control time. Default AsyncScheduler.\n   */\n  static async open(\n    deviceOrId: Device | string,\n    timeoutMs?: number,\n    context?: TraceContext,\n    { rxjsScheduler }: { rxjsScheduler?: SchedulerLike } = {},\n  ): Promise<BleTransport> {\n    return open(deviceOrId, true, timeoutMs, context, { rxjsScheduler });\n  }\n\n  /**\n   * Exposes method from the ble-plx library to disconnect a device\n   *\n   * Disconnects from {@link Device} if it's connected or cancels pending connection.\n   * A \"disconnect\" event will normally be emitted by the ble-plx lib once the device is disconnected.\n   * Errors are logged but silenced.\n   */\n  static disconnectDevice = async (id: string,\n    onDisconnect?: (e?: Error) => void,\n    context?: TraceContext): Promise<void> => {\n    const tracer = new LocalTracer(LOG_TYPE, context);\n    tracer.trace(`Trying to disconnect device ${id}`);\n\n    try {\n      await BleClient.disconnect(id);\n      onDisconnect?.();\n    } catch (error) {\n      // Only log, ignore if disconnect did not work\n      tracer\n        .withType('ble-error')\n        .trace('Error while trying to cancel device connection', { error });\n    }\n    tracer.trace(`Device ${id} disconnected`);\n  };\n\n  device: Device;\n\n  deviceModel: DeviceModel;\n\n  // eslint-disable-next-line no-null/no-null\n  disconnectTimeout: null | ReturnType<typeof setTimeout> = null;\n\n  id: string;\n\n  isConnected = true;\n\n  mtuSize = 20;\n\n  // Observable emitting data received from the device via BLE\n  notifyObservable: Observable<Buffer | Error>;\n\n  notYetDisconnected = true;\n\n  writableWithResponseCharacteristic: Characteristic;\n\n  writableWithoutResponseCharacteristic: Characteristic | undefined;\n\n  rxjsScheduler?: SchedulerLike;\n\n  // Transaction ids of communication operations that are currently pending\n  currentTransactionIds: Array<string>;\n\n  onDisconnect: ((error?: Error) => void) | undefined;\n\n  disconnectCallback: (() => void) | undefined;\n\n  /**\n   * The static `open` function is used to handle `BleTransport` instantiation\n   *\n   * @param device\n   * @param writableWithResponseCharacteristic A BLE characteristic that we can write on,\n   *   and that will be acknowledged in response from the device when it receives the written value.\n   * @param writableWithoutResponseCharacteristic A BLE characteristic that we can write on,\n   *   and that will not be acknowledged in response from the device\n   * @param notifyObservable A multicast observable that emits messages received from the device\n   * @param deviceModel\n   * @param params Contains optional options and injected dependencies used by the transport implementation\n   *  - abortTimeoutMs: stop the exchange after a given timeout. Another timeout exists\n   *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n   *  - rxjsScheduler: dependency injected RxJS scheduler to control time. Default: AsyncScheduler.\n   */\n  constructor(\n    device: Device,\n    writableWithResponseCharacteristic: Characteristic,\n    writableWithoutResponseCharacteristic: Characteristic | undefined,\n    notifyObservable: Observable<Buffer | Error>,\n    deviceModel: DeviceModel,\n    { context, rxjsScheduler }: { context?: TraceContext; rxjsScheduler?: SchedulerLike } = {},\n  ) {\n    super({ context, logType: LOG_TYPE });\n    this.id = device.deviceId;\n    this.device = device;\n    this.writableWithResponseCharacteristic = writableWithResponseCharacteristic;\n    this.writableWithoutResponseCharacteristic = writableWithoutResponseCharacteristic;\n    this.notifyObservable = notifyObservable;\n    this.deviceModel = deviceModel;\n    this.rxjsScheduler = rxjsScheduler;\n    this.currentTransactionIds = [];\n\n    clearDisconnectTimeout(this.id);\n\n    this.tracer.trace(`New instance of BleTransport for device ${this.id}`);\n  }\n\n  /**\n   * A message exchange (APDU request <-> response) with the device that can be aborted.\n   *\n   * The message will be BLE-encoded/framed before being sent, and the response will be BLE-decoded.\n   *\n   * @param message A buffer (u8 array) of a none BLE-encoded message (an APDU for ex) to be sent to the device\n   *   as a request\n   * @param options Contains optional options for the exchange function\n   *  - abortTimeoutMs: stop the exchange after a given timeout. Another timeout exists\n   *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n   * @returns A promise that resolves with the response data from the device.\n   */\n  exchange = (\n    message: Buffer,\n    { abortTimeoutMs }: { abortTimeoutMs?: number } = {},\n  ): Promise<Buffer> => {\n    if (this.exchangeBusyPromise) {\n      void BleTransport.disconnectDevice(this.id, this.onDisconnect);\n    }\n    const tracer = this.tracer.withUpdatedContext({\n      function: 'exchange',\n    });\n    tracer.trace('Exchanging APDU ...', { abortTimeoutMs });\n    tracer.withType('apdu').trace(`=> ${message.toString('hex')}`);\n\n    return this.exchangeAtomicImpl(() => {\n      return firstValueFrom(\n        // `sendApdu` will only emit if an error occurred, otherwise it will complete,\n        // while `receiveAPDU` will emit the full response.\n        // Consequently, it monitors the response while being able to reject on an error from the send.\n        merge(\n          this.notifyObservable.pipe((data) => receiveAPDU(data, { context: tracer.getContext() })),\n          sendAPDU(this.write, message, this.mtuSize, {\n            context: tracer.getContext(),\n          }),\n        ).pipe(\n          abortTimeoutMs ? timeout(abortTimeoutMs, this.rxjsScheduler) : tap(),\n          tap((data) => {\n            tracer.withType('apdu').trace(`<= ${data.toString('hex')}`);\n          }),\n          catchError(async (error) => {\n            // Currently only 1 reason the exchange has been explicitly aborted (other than job and transport errors): a timeout\n            if (error instanceof TimeoutError) {\n              tracer.trace(\n                'Aborting due to timeout and trying to cancel all communication write of the current exchange',\n                {\n                  abortTimeoutMs,\n                  transactionIds: this.currentTransactionIds,\n                },\n              );\n\n              // No concurrent exchange should happen at the same time, so all pending operations are part of the same exchange\n              await this.cancelPendingOperations();\n\n              throw new TransportExchangeTimeoutError('Exchange aborted due to timeout');\n            }\n\n            tracer.withType('ble-error').trace('Error while exchanging APDU', { error });\n\n            if (this.notYetDisconnected) {\n              // In such case we will always disconnect because something is bad.\n              // This sends a `disconnect` event.\n              await BleTransport.disconnectDevice(this.id, this.onDisconnect);\n            }\n\n            const mappedError = remapError(error as IOBleErrorRemap);\n            tracer.trace('Error while exchanging APDU, mapped and throws following error', {\n              mappedError,\n            });\n            // eslint-disable-next-line @typescript-eslint/only-throw-error\n            throw mappedError;\n          }),\n          finalize(() => {\n            tracer.trace('Clearing current transaction ids', {\n              currentTransactionIds: this.currentTransactionIds,\n            });\n            this.clearCurrentTransactionIds();\n          }),\n        ),\n      );\n    });\n  };\n\n  private async cancelPendingOperations() {\n    // BleTransport does not support cancellation\n    await BleTransport.disconnectDevice(this.id, this.onDisconnect);\n  }\n\n  /**\n   * Sets the collection of current transaction ids to an empty array\n   */\n  private clearCurrentTransactionIds() {\n    this.currentTransactionIds = [];\n  }\n\n  /**\n   * Negotiate with the device the maximum transfer unit for the ble frames\n   * @returns Promise<number>\n   */\n  async inferMTU(): Promise<number> {\n    let mtu = (await BleClient.getMtu(this.device.deviceId));\n    this.tracer.trace('Inferring MTU ...', { currentDeviceMtu: mtu });\n\n    await this.exchangeAtomicImpl(async () => {\n      try {\n        mtu = await firstValueFrom(\n          merge(\n            this.notifyObservable.pipe(\n              map((maybeError) => {\n                // Catches the `PairingFailed` Error that has only been emitted\n                if (maybeError instanceof Error) {\n                  throw maybeError;\n                }\n\n                return maybeError;\n              }),\n              first((buffer) => buffer.readUInt8(0) === 0x08),\n              map((buffer) => buffer.readUInt8(5)),\n            ),\n            defer(() => from(this.write(Buffer.from([0x08, 0, 0, 0, 0])))).pipe(ignoreElements()),\n          ),\n        );\n      } catch (error: any) {\n        this.tracer.withType('ble-error').trace('Error while inferring MTU', { mtu });\n\n        await BleTransport.disconnectDevice(this.id, this.onDisconnect);\n\n        const mappedError = remapError(error);\n        this.tracer.trace('Error while inferring APDU, mapped and throws following error', {\n          mappedError,\n        });\n        // eslint-disable-next-line @typescript-eslint/only-throw-error\n        throw mappedError;\n      } finally {\n        // When negotiating the MTU, a message is sent/written to the device, and a transaction id was associated to this write\n        this.clearCurrentTransactionIds();\n      }\n    });\n\n    this.tracer.trace('Successfully negotiated MTU with device', {\n      mtu,\n      mtuSize: this.mtuSize,\n    });\n    if (mtu > 20) {\n      this.mtuSize = mtu;\n    }\n\n    return this.mtuSize;\n  }\n\n  /**\n   * Exposed method from the ble-plx library.\n   * Request the connection priority for the given device.\n   * @returns {Promise<void>}\n   * @param connectionPriority\n   */\n  async requestConnectionPriority(\n    connectionPriority: 'Balanced' | 'High' | 'LowPower',\n  ): Promise<void> {\n    let connectionPriorityMapped: ConnectionPriority;\n    switch (connectionPriority) {\n      case 'High':\n        connectionPriorityMapped = ConnectionPriority.CONNECTION_PRIORITY_BALANCED;\n        break;\n      case 'LowPower':\n        connectionPriorityMapped = ConnectionPriority.CONNECTION_PRIORITY_LOW_POWER;\n        break;\n      case 'Balanced':\n        connectionPriorityMapped = ConnectionPriority.CONNECTION_PRIORITY_BALANCED;\n        break;\n    }\n    await decoratePromiseErrors(\n      BleClient.requestConnectionPriority(this.device.deviceId, connectionPriorityMapped),\n    );\n  }\n\n  /**\n   * Do not call this directly unless you know what you're doing. Communication\n   * with a Ledger device should be through the {@link exchange} method.\n   *\n   * For each call a transaction id is added to the current stack of transaction ids.\n   * With this transaction id, a pending BLE communication operations can be cancelled.\n   * Note: each frame/packet of a longer BLE-encoded message to be sent should have their unique transaction id.\n   *\n   * @param buffer BLE-encoded packet to send to the device\n   * @param frameId Frame id to make `write` aware of a bigger message that this frame/packet is part of.\n   *  Helps to create related a collection of transaction ids\n   */\n  write = async (buffer: Buffer): Promise<void> => {\n    const transactionId = uuid();\n    this.currentTransactionIds.push(transactionId);\n\n    const tracer = this.tracer.withUpdatedContext({ transactionId });\n    tracer.trace('Writing to device', {\n      willMessageBeAcked: !this.writableWithoutResponseCharacteristic,\n    });\n\n    try {\n      const uint8Array = new Uint8Array(buffer);\n      const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n      await BleClient.write(\n        this.device.deviceId,\n        currentDeviceService!,\n        this.writableWithResponseCharacteristic.uuid,\n        dataView,\n      );\n      tracer.withType('ble-frame').trace(`=> ${buffer.toString('hex')}`);\n    } catch (error: unknown) {\n      tracer.trace('Error while writing APDU', { error });\n      throw new DisconnectedDeviceDuringOperation(\n        error instanceof Error ? error.message : `${String(error)}`,\n      );\n    }\n  };\n\n  /**\n   * We intentionally do not immediately close a transport connection.\n   * Instead, we queue the disconnect and wait for a future connection to dismiss the event.\n   * This approach prevents unnecessary disconnects and reconnects. We use the isConnected\n   * flag to ensure that we do not trigger a disconnect if the current cached transport has\n   * already been disconnected.\n   * @returns {Promise<void>}\n   */\n  async close(): Promise<void> {\n    const tracer = this.tracer.withUpdatedContext({ function: 'close' });\n    tracer.trace('Closing, queuing a disconnect with a timeout ...');\n\n    let resolve: (value: void | PromiseLike<void>) => void;\n    const disconnectPromise = new Promise<void>((innerResolve) => {\n      resolve = innerResolve;\n    });\n\n    clearDisconnectTimeout(this.id);\n\n    this.disconnectTimeout = setTimeout(() => {\n      tracer.trace('Disconnect timeout has been reached ...');\n      if (this.isConnected) {\n        BleTransport.disconnectDevice(this.id, this.onDisconnect, tracer.getContext())\n          .catch(() => {})\n          .finally(resolve);\n      } else {\n        resolve();\n      }\n    }, BleTransport.disconnectTimeoutMs);\n\n    // The closure will occur no later than 5s, triggered either by disconnection\n    // or the actual response of the apdu.\n    await Promise.race([this.exchangeBusyPromise || Promise.resolve(), disconnectPromise]);\n  }\n}\n\n/**\n * Opens a BLE connection with a given device. Returns a Transport instance.\n *\n * @param deviceOrId\n * @param needsReconnect\n * @param timeoutMs Optional Timeout (in ms) applied during the connection with the device\n * @param context Optional tracing/log context\n * @param injectedDependencies Contains optional injected dependencies used by the transport implementation\n *  - rxjsScheduler: dependency injected RxJS scheduler to control time. Default AsyncScheduler.\n * @returns A BleTransport instance\n */\nasync function open(\n  deviceOrId: Device | string,\n  needsReconnect: boolean,\n  timeoutMs?: number,\n  context?: TraceContext,\n  { rxjsScheduler }: { rxjsScheduler?: SchedulerLike } = {},\n) {\n  const tracer = new LocalTracer(LOG_TYPE, context);\n  let device: Device;\n  tracer.trace(`Opening ${typeof deviceOrId === 'string' ? deviceOrId : deviceOrId.deviceId}`, { needsReconnect });\n  let deviceId: string;\n  // eslint-disable-next-line prefer-const\n  let transport: BleTransport;\n\n  if (typeof deviceOrId === 'string') {\n    deviceId = deviceOrId;\n    if (transportsCache[deviceOrId]) {\n      tracer.trace('Transport in cache, using it');\n      clearDisconnectTimeout(deviceOrId);\n\n      // The cached transport probably has an older trace/log context\n      transportsCache[deviceOrId].setTraceContext(context);\n      return transportsCache[deviceOrId];\n    }\n\n    tracer.trace(`Trying to open device: ${deviceOrId}`);\n    await awaitsBleOn();\n\n    // Returns a list of known devices by their identifiers\n    const devices = (await BleClient.getDevices([deviceOrId]));\n    tracer.trace(`Found ${devices.length} already known device(s) with given id`, { deviceOrId });\n    [device] = devices;\n\n    if (!device) {\n      // Returns a list of the peripherals currently connected to the system\n      // which have discovered services, connected to system doesn't mean\n      // connected to our app, we check that below.\n      const services = (await BleClient.getServices(deviceOrId)).map((it) => it.uuid);\n      const connectedDevices = (await BleClient.getConnectedDevices(services));\n      const connectedDevicesFiltered = connectedDevices.filter((d) => d.deviceId === deviceOrId);\n      tracer.trace(\n        `No known device with given id.\n        Found ${connectedDevicesFiltered.length} devices from already connected devices`,\n        { deviceOrId },\n      );\n      [device] = connectedDevicesFiltered;\n    }\n\n    if (!device) {\n      // We still don't have a device, so we attempt to connect to it.\n      tracer.trace('No known nor connected devices with given id. Trying to connect to device', {\n        deviceOrId,\n        timeoutMs,\n      });\n\n      // Nb ConnectionOptions dropped since it's not used internally by ble-plx.\n      try {\n        await BleClient.connect(deviceOrId, () => {\n          transport.onDisconnect?.();\n        }, {\n          timeout: timeoutMs,\n        });\n      } catch (e: any) {\n        tracer.trace(`Error code: ${e.errorCode}`);\n        throw e;\n      }\n    }\n\n    if (!device) {\n      throw new CantOpenDevice();\n    }\n  } else {\n    // It was already a Device\n    device = deviceOrId;\n    deviceId = deviceOrId.deviceId;\n  }\n\n  const connectedDevices = await BleClient.getConnectedDevices(getBluetoothServiceUuids());\n\n  if (!connectedDevices.find((it) => it.deviceId === deviceId)) {\n    tracer.trace('Device found but not connected. connecting...', { timeoutMs, connectOptions });\n    try {\n      await BleClient.connect(deviceId, () => {\n        transport.onDisconnect?.();\n      }, {\n        timeout: timeoutMs,\n      });\n    } catch (error: any) {\n      tracer.trace('Connect error', { error });\n      // eslint-disable-next-line @typescript-eslint/only-throw-error\n      throw remapError(error);\n    }\n  }\n\n  tracer.trace('Device is connected now, getting services and characteristics');\n\n  let services: BleService[] = [];\n\n  await BleClient.discoverServices(deviceId);\n  services = (await BleClient.getServices(deviceId));\n\n  let res: BluetoothInfos | undefined = retrieveInfos(device);\n  const characteristics: BleCharacteristic[] = [];\n\n  if (!res) {\n    for (const serviceUUID of getBluetoothServiceUuids()) {\n      try {\n        const deviceService = services.find((it) => it.uuid === serviceUUID);\n        res = getInfosForServiceUuid(serviceUUID);\n        if (res && deviceService) {\n          characteristics.push(...deviceService.characteristics);\n          currentDeviceService = res.serviceUuid;\n          break;\n        }\n      } catch (e) {\n        // Attempt to connect to the next service\n      }\n    }\n  }\n\n  if (!res) {\n    tracer.trace('Service not found');\n    throw new TransportError('service not found', 'BLEServiceNotFound');\n  }\n\n  const {\n    deviceModel, writeUuid, writeCmdUuid, notifyUuid,\n  } = res;\n\n  /* if (!characteristics) {\n    characteristics = await device.characteristicsForService(serviceUuid);\n  } */\n\n  if (!characteristics) {\n    tracer.trace('Characteristics not found');\n    throw new TransportError('service not found', 'BLEServiceNotFound');\n  }\n\n  let writableWithResponseCharacteristic: Characteristic | null | undefined;\n  let writableWithoutResponseCharacteristic: Characteristic | undefined;\n  // A characteristic that can monitor value changes\n  let notifiableCharacteristic: Characteristic | null | undefined;\n\n  for (const c of characteristics) {\n    if (c.uuid === writeUuid) {\n      writableWithResponseCharacteristic = c;\n    } else if (c.uuid === writeCmdUuid) {\n      writableWithoutResponseCharacteristic = c;\n    } else if (c.uuid === notifyUuid) {\n      notifiableCharacteristic = c;\n    }\n  }\n\n  if (!writableWithResponseCharacteristic) {\n    throw new TransportError('write characteristic not found', 'BLECharacteristicNotFound');\n  }\n\n  if (!notifiableCharacteristic) {\n    throw new TransportError('notify characteristic not found', 'BLECharacteristicNotFound');\n  }\n\n  if (!writableWithResponseCharacteristic.properties.write) {\n    throw new TransportError(\n      'The writable-with-response characteristic is not writable with response',\n      'BLECharacteristicInvalid',\n    );\n  }\n\n  if (!notifiableCharacteristic.properties.notify) {\n    throw new TransportError('notify characteristic not notifiable', 'BLECharacteristicInvalid');\n  }\n\n  if (writableWithoutResponseCharacteristic) {\n    if (!writableWithoutResponseCharacteristic.properties.writeWithoutResponse) {\n      throw new TransportError(\n        'The writable-without-response characteristic is not writable without response',\n        'BLECharacteristicInvalid',\n      );\n    }\n  }\n\n  const deviceMtu = await BleClient.getMtu(device.deviceId);\n  tracer.trace(`device.mtu=${deviceMtu}`);\n\n  // Inits the observable that will emit received data from the device via BLE\n  const notifyObservable = monitorCharacteristic(deviceId,\n    currentDeviceService!,\n    notifiableCharacteristic,\n    context).pipe(\n    catchError((e) => {\n      // LL-9033 fw 2.0.2 introduced this case, we silence the inner unhandled error.\n      // It will be handled when negotiating the MTU in `inferMTU` but will be ignored in other cases.\n      const msg = String(e);\n      return msg.includes('notify change failed')\n        ? of(new PairingFailed(msg))\n        : throwError(() => e);\n    }),\n    tap((value) => {\n      if (value instanceof PairingFailed) return;\n      trace({ type: 'ble-frame', message: `<= ${value.toString('hex')}`, context });\n    }),\n    // Returns a new Observable that multicasts (shares) the original Observable.\n    // As long as there is at least one Subscriber this Observable will be subscribed and emitting data.\n    share(),\n  );\n\n  // Keeps the input from the device observable alive (multicast observable)\n  const notif = notifyObservable.subscribe();\n\n  transport = new BleTransport(\n    device,\n    writableWithResponseCharacteristic,\n    writableWithoutResponseCharacteristic,\n    notifyObservable,\n    deviceModel,\n    {\n      context,\n      rxjsScheduler,\n    },\n  );\n  tracer.trace('New BleTransport created');\n\n  // Keeping it as a comment for now but if no new bluetooth issues occur, we will be able to remove it\n  // await transport.requestConnectionPriority(\"High\");\n\n  // let disconnectedSub: Subscription;\n\n  // Callbacks on `react-native-ble-plx` notifying the device has been disconnected\n  transport.onDisconnect = (error?: Error) => {\n    transport.isConnected = false;\n    transport.notYetDisconnected = false;\n    notif.unsubscribe();\n    // disconnectedSub?.remove();\n\n    clearDisconnectTimeout(transport.id);\n    delete transportsCache[transport.id];\n    tracer.trace(\n      `On device disconnected callback: cleared cached transport for ${transport.id},\n      emitting Transport event \"disconnect. Error: ${error}\"`,\n      { reason: error },\n    );\n    transport.emit('disconnect', error);\n    transport.disconnectCallback?.();\n  };\n\n  transportsCache[transport.id] = transport;\n  const beforeMTUTime = Date.now();\n\n  /* disconnectedSub = device.onDisconnected((e) => {\n    if (!transport.notYetDisconnected) return;\n    onDisconnect(e);\n  }); */\n\n  try {\n    await transport.inferMTU();\n  } finally {\n    const afterMTUTime = Date.now();\n\n    if (reconnectionConfig) {\n      // Refer to ledgerjs archived repo issue #279.\n      // All HW .v1 LNX have a bug that prevents us from communicating with the device right after pairing.\n      // When we connect for the first time we issue a disconnect and reconnect, this guarantees that we are\n      // in a good state. This is avoidable in some key scenarios ↓\n      if (afterMTUTime - beforeMTUTime < reconnectionConfig.pairingThreshold) {\n        needsReconnect = false;\n      } else if (deviceModel.id === DeviceModelId.stax) {\n        tracer.trace('Skipping \"needsReconnect\" strategy for Stax');\n        needsReconnect = false;\n      }\n\n      if (needsReconnect) {\n        tracer.trace('Device needs reconnection. Triggering a disconnect');\n        await BleTransport.disconnectDevice(transport.id, transport.onDisconnect);\n        await delay(reconnectionConfig.delayAfterFirstPairing);\n      }\n    } else {\n      needsReconnect = false;\n    }\n  }\n\n  if (needsReconnect) {\n    tracer.trace('Reconnecting');\n    return open(device, false, timeoutMs, context);\n  }\n\n  return transport;\n}\n","import { BluetoothLe } from '@capacitor-community/bluetooth-le';\nimport { BluetoothRequired } from '@ledgerhq/errors';\n\nexport async function awaitsBleOn(): Promise<void> {\n  await BluetoothLe.initialize();\n  const isEnabled = await BluetoothLe.isEnabled();\n  if (!isEnabled) {\n    throw new BluetoothRequired('', {\n      state: 'disable',\n    });\n  }\n}\n","import { BleClient } from '@capacitor-community/bluetooth-le';\nimport type { Subscription as TransportSubscription } from '@ledgerhq/hw-transport';\nimport { v4 as uuid } from 'uuid';\nimport type { BleDevice } from '@capacitor-community/bluetooth-le/dist/esm/definitions';\n\nimport { IS_CAPACITOR } from '../../config';\nimport BleTransport from '../../lib/ledger-hw-transport-ble/BleTransport';\nimport { logDebug, logDebugError } from '../logs';\nimport { pause } from '../schedulers';\nimport { IS_ANDROID, IS_IOS } from '../windowEnvironment';\nimport { DEVICE_DETECT_ATTEMPTS, PAUSE } from './constants';\n\ninterface ScannedDevice {\n  identifier: string;\n  device: BleDevice;\n}\n\nexport interface LedgerConnection {\n  device: BleDevice;\n  bleTransport: BleTransport;\n}\n\nlet isBleInitialized = false;\nlet bleInitializationPromise: Promise<void> | undefined;\n\nlet listeningSubscription: TransportSubscription | undefined;\n\nlet scannedDevices: ScannedDevice[] = [];\nlet pairedDevice: LedgerConnection | undefined;\nlet onLedgerConnected: ((connection: LedgerConnection) => void) | undefined;\n\nfunction isConnecting() {\n  return !!listeningSubscription;\n}\n\nfunction scannedDeviceIsValidYet(scannedDevice: ScannedDevice): boolean {\n  if (!scannedDevices.find((it) => it.identifier === scannedDevice.identifier)) {\n    // List is already cleared\n    return false;\n  }\n\n  // A device is already paired\n  return !pairedDevice;\n}\n\nasync function tryConnectingLedgerDevice(scannedDevice: ScannedDevice) {\n  try {\n    // Check if stopped before retry\n    if (!scannedDeviceIsValidYet(scannedDevice)) return;\n\n    const bleTransport = await BleTransport.open(scannedDevice.device);\n    // Check if stopped before connection establish\n    if (!scannedDeviceIsValidYet(scannedDevice)) return;\n\n    const ledgerConnection = {\n      device: scannedDevice.device,\n      bleTransport,\n    };\n    pairedDevice = ledgerConnection;\n\n    bleTransport.disconnectCallback = () => {\n      pairedDevice = undefined;\n      if (isConnecting()) {\n        stop();\n        void start();\n      }\n    };\n\n    setTimeout(() => {\n      // Make sure not disconnected yet\n      if (pairedDevice?.device.deviceId === ledgerConnection.device.deviceId) {\n        onLedgerConnected?.(ledgerConnection);\n        stop();\n      } else if (isConnecting()) {\n        // Unexpectedly, disconnected before calling the callback, restart!\n        pairedDevice = undefined;\n        stop();\n        void start();\n      }\n    }, 1000);\n  } catch (error) {\n    setTimeout(() => {\n      void tryConnectingLedgerDevice(scannedDevice);\n    }, 10000);\n  }\n}\n\nasync function isSupported() {\n  if (!IS_CAPACITOR) return false;\n\n  let isEnabled = false;\n  try {\n    await ensureBleInitialized();\n    if (IS_ANDROID) {\n      await BleClient.requestEnable();\n    }\n\n    isEnabled = await BleClient.isEnabled();\n    logDebug('BLE isSupported result', { isEnabled });\n  } catch (err: any) {\n    logDebugError('Error while checking BLE availability', err);\n  }\n\n  return isEnabled;\n}\n\nasync function start() {\n  await ensureBleInitialized();\n\n  listeningSubscription = BleTransport.listen({\n    next: (event: { type: string; device?: BleDevice }) => {\n      switch (event.type) {\n        case 'add':\n          if (event.device) {\n            if (!event.device.name) return;\n            if (scannedDevices.find((it) => it.device.deviceId === event.device?.deviceId)) return;\n            const scannedDevice = { identifier: uuid(), device: event.device };\n            scannedDevices.push(scannedDevice);\n            void tryConnectingLedgerDevice(scannedDevice);\n          }\n          break;\n      }\n    },\n    error: () => {\n      stop();\n    },\n    complete: () => {\n      stop();\n    },\n  });\n}\n\nfunction stop() {\n  scannedDevices = [];\n  listeningSubscription?.unsubscribe();\n  listeningSubscription = undefined;\n}\n\nfunction connect(): Promise<LedgerConnection> {\n  return new Promise((resolve) => {\n    onLedgerConnected = resolve;\n    if (pairedDevice) {\n      onLedgerConnected(pairedDevice);\n      return;\n    }\n\n    if (isConnecting()) return;\n    void start();\n  });\n}\n\nasync function openSettings() {\n  if (IS_ANDROID) {\n    await BleClient.openBluetoothSettings();\n  } else if (IS_IOS) {\n    await BleClient.openAppSettings();\n  }\n}\n\nexport const BleConnector = {\n  isSupported,\n  connect,\n  stop,\n  openSettings,\n};\n\nasync function ensureBleInitialized(): Promise<void> {\n  if (isBleInitialized) return;\n  if (bleInitializationPromise) return bleInitializationPromise;\n\n  bleInitializationPromise = (async () => {\n    let attempt = 0;\n    let lastError: Error | undefined;\n\n    while (attempt < DEVICE_DETECT_ATTEMPTS && !isBleInitialized) {\n      try {\n        await BleClient.initialize({\n          androidNeverForLocation: true,\n        });\n        isBleInitialized = true;\n        return;\n      } catch (err: any) {\n        lastError = err;\n\n        logDebugError('BLE initialize attempt failed', err);\n        await pause(PAUSE * attempt);\n      }\n\n      attempt += 1;\n    }\n\n    if (!isBleInitialized) {\n      throw lastError ?? new Error('BLE initialize failed');\n    }\n  })()\n    .finally(() => {\n      bleInitializationPromise = undefined;\n    });\n\n  return bleInitializationPromise;\n}\n"],"names":["remapError","error","message","includes","DisconnectedDevice","rethrowError","e","Error","LOG_TYPE","reconnectionConfig","pairingThreshold","delayAfterFirstPairing","bluetoothInfoCache","transportsCache","connectOptions","requestMTU","connectionPriority","clearDisconnectTimeout","deviceId","context","cachedTransport","disconnectTimeout","trace","type","clearTimeout","currentDeviceService","BleTransport","Transport","static","list","listen","observer","unsubscribed","LocalTracer","BleClient","getConnectedDevices","getBluetoothServiceUuids","then","async","it","devices","next","device","stopLEScan","requestLEScan","services","result","unsubscribe","open","deviceOrId","timeoutMs","rxjsScheduler","arguments","length","undefined","id","onDisconnect","tracer","disconnect","withType","isConnected","mtuSize","notYetDisconnected","constructor","writableWithResponseCharacteristic","writableWithoutResponseCharacteristic","notifyObservable","deviceModel","super","logType","this","currentTransactionIds","exchange","_this","abortTimeoutMs","exchangeBusyPromise","disconnectDevice","withUpdatedContext","function","toString","exchangeAtomicImpl","firstValueFrom","merge","pipe","data","receiveAPDU","getContext","sendAPDU","write","timeout","tap","catchError","TimeoutError","transactionIds","cancelPendingOperations","TransportExchangeTimeoutError","mappedError","finalize","clearCurrentTransactionIds","inferMTU","mtu","getMtu","currentDeviceMtu","map","maybeError","first","buffer","readUInt8","defer","from","Buffer","ignoreElements","requestConnectionPriority","connectionPriorityMapped","ConnectionPriority","CONNECTION_PRIORITY_BALANCED","CONNECTION_PRIORITY_LOW_POWER","promise","catch","transactionId","uuid","push","willMessageBeAcked","uint8Array","Uint8Array","dataView","DataView","byteOffset","byteLength","DisconnectedDeviceDuringOperation","String","close","resolve","disconnectPromise","Promise","innerResolve","setTimeout","finally","disconnectTimeoutMs","race","needsReconnect","transport","setTraceContext","BluetoothLe","initialize","isEnabled","BluetoothRequired","state","awaitsBleOn","getDevices","getServices","connectedDevicesFiltered","filter","d","connect","_transport$onDisconne","_transport","call","errorCode","CantOpenDevice","find","_transport$onDisconne2","_transport2","discoverServices","res","uuids","serviceUUID","infos","getInfosForServiceUuid","retrieveInfos","characteristics","deviceService","serviceUuid","TransportError","writeUuid","writeCmdUuid","notifyUuid","notifiableCharacteristic","c","properties","notify","writeWithoutResponse","deviceMtu","monitorCharacteristic","serviceId","characteristic","Observable","o","characteristicUuid","startNotifications","value","stopEnabledNotifications","msg","of","PairingFailed","throwError","share","notif","subscribe","_transport$disconnect","_transport3","reason","emit","disconnectCallback","beforeMTUTime","Date","now","afterMTUTime","DeviceModelId","stax","ms","success","bleInitializationPromise","listeningSubscription","pairedDevice","onLedgerConnected","isBleInitialized","scannedDevices","isConnecting","scannedDeviceIsValidYet","scannedDevice","identifier","tryConnectingLedgerDevice","bleTransport","ledgerConnection","stop","start","_pairedDevice","_onLedgerConnected","ensureBleInitialized","event","name","_event$device","complete","_listeningSubscriptio","BleConnector","isSupported","IS_CAPACITOR","IS_ANDROID","requestEnable","logDebug","err","logDebugError","openSettings","openBluetoothSettings","IS_IOS","openAppSettings","lastError","attempt","DEVICE_DETECT_ATTEMPTS","androidNeverForLocation","pause","PAUSE"],"sourceRoot":""}